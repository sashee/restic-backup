AWSTemplateFormatVersion: 2010-09-09
Parameters:
  ManagementAccountId:
    Type: String
    Description: "The account ID of the management account"
  NotificationSNSTopicArn:
    Type: String
    Description: "The topic that will be notified when the user is disabled"
  Monitors:
    Type: String
    Default: "base"
    Description: "Comma-separated list of available monitors"
Resources:
  Bucket:
    Type: AWS::S3::Bucket
    Properties:
      LifecycleConfiguration:
        Rules:
          - Status: Enabled
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 180
            NoncurrentVersionExpiration:
              NoncurrentDays: 180
          - Status: Enabled
            Prefix: "data/"
            ObjectSizeGreaterThan: 1048576
            Transitions:
              - StorageClass: INTELLIGENT_TIERING
                TransitionInDays: 0
            NoncurrentVersionTransitions:
              - StorageClass: DEEP_ARCHIVE
                TransitionInDays: 0
      VersioningConfiguration:
        Status: Enabled
  BackupUser:
    Type: AWS::IAM::User
    Properties:
      Policies:
      - PolicyName: backup
        PolicyDocument:
           Version: 2012-10-17
           Statement:
              - Effect: Allow
                Action:
                 - 's3:ListBucket'
                 - 's3:GetBucketLocation'
                Resource: !GetAtt Bucket.Arn
              - Effect: Allow
                Action:
                 - 's3:GetObject'
                 - 's3:PutObject'
                 - 's3:DeleteObject'
                Resource: !Sub "${Bucket.Arn}/*"
  MonitoringUser:
    Type: AWS::IAM::User
    Properties:
      Policies:
      - PolicyName: backup
        PolicyDocument:
           Version: 2012-10-17
           Statement:
              - Effect: Allow
                Action:
                - 'lambda:InvokeFunctionUrl'
                Resource: !GetAtt MonitoringLambdaUrl.FunctionArn
# access denied disabler
  CloudTrailSNSTopic:
    Type: AWS::SNS::Topic
  SNSTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            AWS: !Ref ManagementAccountId
          Action: sns:Publish
          Resource: "*"
      Topics:
      - !Ref CloudTrailSNSTopic
  Queue: 
    Type: AWS::SQS::Queue
  QueuePolicy: 
    Type: AWS::SQS::QueuePolicy
    Properties: 
      Queues: 
        - !Ref Queue
      PolicyDocument: 
        Statement: 
          - Action: "sqs:SendMessage" 
            Effect: "Allow"
            Resource: !GetAtt Queue.Arn
            Principal:  
              Service: "sns.amazonaws.com"
            Condition:
              ArnEquals:
                "aws:SourceArn": !Ref CloudTrailSNSTopic
  SQSLogGroup: 
    Type: AWS::Logs::LogGroup
    Properties: 
      RetentionInDays: 365
  PipeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - pipes.amazonaws.com
          Action:
          - sts:AssumeRole
          Condition:
            StringEquals:
              'aws:SourceArn': !Sub
                - 'arn:${AWS::Partition}:pipes:${AWS::Region}:${AWS::AccountId}:pipe/${PipeName}'
                - PipeName: !Select [2, !Split ['/', !Ref AWS::StackId]]
      Policies:
        - PolicyName: allow-logs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action:
              - 'sqs:ReceiveMessage'
              - 'sqs:DeleteMessage'
              - 'sqs:GetQueueAttributes'
              Resource: !GetAtt Queue.Arn
            - Effect: Allow
              Action:
              - 'logs:PutLogEvents'
              - 'logs:CreateLogStream'
              Resource: !Sub "${SQSLogGroup.Arn}:*"
  SQSToCloudWatchLogs:
    Type: 'AWS::Pipes::Pipe'
    Properties:
      Name: !Select [2, !Split ['/', !Ref AWS::StackId]]
      RoleArn: !GetAtt PipeRole.Arn
      Source: !GetAtt Queue.Arn
      Target: !GetAtt SQSLogGroup.Arn
      TargetParameters:
        InputTemplate: "<$.tody.Message>"
  QueueSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Endpoint: !GetAtt Queue.Arn
      Protocol: sqs
      TopicArn: !Ref CloudTrailSNSTopic
      FilterPolicyScope: MessageBody
      FilterPolicy:
        "$or":
          - errorCode:
            - AccessDenied
          - eventName:
            - GetCallerIdentity
        userIdentity:
          arn:
            - !GetAtt BackupUser.Arn
            - !GetAtt MonitoringUser.Arn
  DisablerLambdaLogGroup: 
    Type: AWS::Logs::LogGroup
    Properties: 
      RetentionInDays: 365
  DisablerLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: allow-logs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action:
              - 'logs:PutLogEvents'
              - 'logs:CreateLogStream'
              Resource: !Sub "${DisablerLambdaLogGroup.Arn}:*"
            - Effect: Allow
              Action:
              - 'iam:AttachUserPolicy'
              Resource:
              - !GetAtt BackupUser.Arn
              - !GetAtt MonitoringUser.Arn
              Condition:
                StringEquals:
                  "iam:PolicyARN": "arn:aws:iam::aws:policy/AWSDenyAll"
            - Effect: Allow
              Action:
              - 'sns:Publish'
              Resource: !Ref NotificationSNSTopicArn
  DisablerLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs20.x
      Role: !GetAtt DisablerLambdaExecutionRole.Arn
      Handler: index.handler
#     ReservedConcurrentExecutions: 1
      Timeout: 30
      Code:
        ZipFile: |
          const {IAMClient, AttachUserPolicyCommand} = require("@aws-sdk/client-iam");
          const {SNSClient, PublishCommand} = require("@aws-sdk/client-sns");

          exports.handler = async (event) => {
            await new IAMClient().send(new AttachUserPolicyCommand({
              UserName: process.env.BackupUserName,
              PolicyArn: "arn:aws:iam::aws:policy/AWSDenyAll",
            }));
            await new IAMClient().send(new AttachUserPolicyCommand({
              UserName: process.env.MonitoringUserName,
              PolicyArn: "arn:aws:iam::aws:policy/AWSDenyAll",
            }));

            const client = new SNSClient({region: process.env.NotificationSNSTopicArn.split(":")[3]});
            await client.send(new PublishCommand({
              Message: `User disabled. Check logs at https://${process.env.AWS_REGION}.console.aws.amazon.com/cloudwatch/home#logsV2:log-groups/log-group/${process.env.SQSLogGroup.replaceAll("/", "$252F")}/log-events`,
              TopicArn: process.env.NotificationSNSTopicArn,
            }));
          };
      LoggingConfig:
        LogGroup: !Ref DisablerLambdaLogGroup
        LogFormat: JSON
      Environment:
        Variables:
          BackupUserName: !Ref BackupUser
          MonitoringUserName: !Ref MonitoringUser
          NotificationSNSTopicArn: !Ref NotificationSNSTopicArn
          SQSLogGroup: !Ref SQSLogGroup
  AccessDeniedAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      Threshold: 0
      Namespace: "AWS/SQS"
      MetricName: "NumberOfMessagesSent"
      Dimensions:
        - Name: QueueName
          Value: !GetAtt Queue.QueueName
      Statistic: Maximum
      Period: 60
      TreatMissingData: notBreaching
      ActionsEnabled: true
      AlarmActions:
      - !GetAtt DisablerLambdaFunction.Arn
  InvokeDisablerLambdaPermission: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !GetAtt DisablerLambdaFunction.Arn
      Action: "lambda:InvokeFunction"
      Principal: "lambda.alarms.cloudwatch.amazonaws.com"
      SourceArn: !GetAtt AccessDeniedAlarm.Arn
# monitoring
  RunIDTable: 
    Type: AWS::DynamoDB::Table
    Properties: 
      AttributeDefinitions: 
        - AttributeName: "RunID"
          AttributeType: "S"
      KeySchema: 
        - AttributeName: "RunID"
          KeyType: "HASH"
      BillingMode: PAY_PER_REQUEST
      OnDemandThroughput:
        MaxReadRequestUnits: 5
        MaxWriteRequestUnits: 5
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
  RunsTable: 
    Type: AWS::DynamoDB::Table
    Properties: 
      AttributeDefinitions: 
        - AttributeName: "InternalID"
          AttributeType: "S"
        - AttributeName: "Monitor"
          AttributeType: "S"
        - AttributeName: "StartTime"
          AttributeType: "N"
      KeySchema: 
        - AttributeName: "InternalID"
          KeyType: "HASH"
      BillingMode: PAY_PER_REQUEST
      OnDemandThroughput:
        MaxReadRequestUnits: 5
        MaxWriteRequestUnits: 5
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      GlobalSecondaryIndexes: 
        - IndexName: "ByMonitor"
          KeySchema: 
            - AttributeName: "Monitor"
              KeyType: "HASH"
            - AttributeName: "StartTime"
              KeyType: "RANGE"
          OnDemandThroughput:
            MaxReadRequestUnits: 5
            MaxWriteRequestUnits: 5
          Projection: 
            ProjectionType: "ALL"
  LogsTable: 
    Type: AWS::DynamoDB::Table
    Properties: 
      AttributeDefinitions: 
        - AttributeName: "InternalID"
          AttributeType: "S"
        - AttributeName: "Time"
          AttributeType: "N"
      KeySchema: 
        - AttributeName: "InternalID"
          KeyType: "HASH"
        - AttributeName: "Time"
          KeyType: "RANGE"
      BillingMode: PAY_PER_REQUEST
      OnDemandThroughput:
        MaxReadRequestUnits: 5
        MaxWriteRequestUnits: 5
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
  MonitoringLambdaLogGroup: 
    Type: AWS::Logs::LogGroup
    Properties: 
      RetentionInDays: 365
  MonitoringLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: allow-logs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action:
              - 'logs:PutLogEvents'
              - 'logs:CreateLogStream'
              Resource: !Sub "${MonitoringLambdaLogGroup.Arn}:*"
            - Effect: Allow
              Action:
              - 'dynamodb:GetItem'
              - 'dynamodb:PutItem'
              Resource: !GetAtt RunIDTable.Arn
            - Effect: Allow
              Action:
              - 'dynamodb:PutItem'
              - 'dynamodb:UpdateItem'
              Resource: !GetAtt RunsTable.Arn
            - Effect: Allow
              Action:
              - 'dynamodb:PutItem'
              Resource: !GetAtt LogsTable.Arn
  MonitoringLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs20.x
      Role: !GetAtt MonitoringLambdaExecutionRole.Arn
      Handler: index.handler
#     ReservedConcurrentExecutions: 1
      Timeout: 30
      Code:
        ZipFile: |
          const {DynamoDBClient, GetItemCommand, PutItemCommand, UpdateItemCommand} = require("@aws-sdk/client-dynamodb");
          const crypto = require("crypto");
          const zlib = require("node:zlib");
          const {promisify} = require("node:util");

          exports.handler = async (event) => {
            const {body, ...rest} = event;
            console.log({...rest, bodyLength: body?.length});
            const client = new DynamoDBClient();
            if (event.requestContext.http.path === "/run") {
              const {runid, monitor} = event.queryStringParameters;
              const internalId = crypto.randomUUID();
              console.log({message: "starting monitoring run", internalId});
              try {
                if (!process.env.Monitors.split(",").includes(monitor)) {
                  throw new Error(`Monitor not defined: ${monitor}`);
                };
                await client.send(new PutItemCommand({
                  TableName: process.env.RunIDTable,
                  Item: {
                    RunID: {S: runid},
                    InternalID: {S: internalId},
                    Monitor: {S: monitor},
                    ttl: {N: String(Math.round((new Date().getTime() + 365 * 24 * 60 * 60 * 1000) / 1000))},
                  },
                  ConditionExpression: "attribute_not_exists(#pk)",
                  ExpressionAttributeNames: {
                    "#pk": "RunID",
                  },
                }));
                await client.send(new PutItemCommand({
                  TableName: process.env.RunsTable,
                  Item: {
                    InternalID: {S: internalId},
                    StartTime: {N: String(new Date().getTime())},
                    Monitor: {S: monitor},
                    ttl: {N: String(Math.round((new Date().getTime() + 365 * 24 * 60 * 60 * 1000) / 1000))},
                  },
                  ConditionExpression: "attribute_not_exists(#pk)",
                  ExpressionAttributeNames: {
                    "#pk": "InternalID",
                  },
                }));
              }catch(e) {
                console.log({message: "starting monitoring run: error", internalId, e});
                throw e;
              }
            } else if (event.requestContext.http.path === "/log") {
              const {runid, label} = event.queryStringParameters;
              const bodyBuffer = Buffer.from(body, event.isBase64Encoded ? "base64" : "utf8");

              const item = await client.send(new GetItemCommand({
                TableName: process.env.RunIDTable,
                Key: {
                  RunID: {S: runid},
                },
              }));
              const internalId = item.Item.InternalID.S;
              console.log({message: "logging", internalId});

              const compressed = await promisify(zlib.brotliCompress)(bodyBuffer, {params: {
                [zlib.constants.BROTLI_PARAM_MODE]: zlib.constants.BROTLI_MODE_TEXT,
                [zlib.constants.BROTLI_PARAM_QUALITY]: zlib.constants.BROTLI_MAX_QUALITY,
                [zlib.constants.BROTLI_PARAM_SIZE_HINT]: bodyBuffer.length,
              }});
              console.log({type: "compressed", original: bodyBuffer.length, compressed: compressed.length});
              await client.send(new PutItemCommand({
                TableName: process.env.LogsTable,
                Item: {
                  InternalID: {S: internalId},
                  Time: {N: String(new Date().getTime())},
                  Label: {S: label},
                  Message: {B: compressed.toString("base64")},
                  ttl: {N: String(Math.round((new Date().getTime() + 365 * 24 * 60 * 60 * 1000) / 1000))},
                },
                ConditionExpression: "attribute_not_exists(#pk)",
                ExpressionAttributeNames: {
                  "#pk": "InternalID",
                },
              }));
            } else if (["/success", "/fail"].includes(event.requestContext.http.path)) {
              const {runid} = event.queryStringParameters;
              const item = await client.send(new GetItemCommand({
                TableName: process.env.RunIDTable,
                Key: {
                  RunID: {S: runid},
                },
              }));
              const internalId = item.Item.InternalID.S;
              console.log({message: "finishing monitoring run", internalId});
              try {
                await client.send(new UpdateItemCommand({
                  TableName: process.env.RunsTable,
                  Key: {
                    InternalID: {S: internalId},
                  },
                  ConditionExpression: "attribute_exists(#pk) and attribute_not_exists(#Success)",
                  UpdateExpression: "SET #EndTime = :EndTime, #Success = :Success",
                  ExpressionAttributeNames: {
                    "#pk": "InternalID",
                    "#EndTime": "EndTime",
                    "#Success": "Success",
                  },
                  ExpressionAttributeValues: {
                    ":EndTime": {N: String(new Date().getTime())},
                    ":Success": {BOOL: String(event.requestContext.http.path === "/success")},
                  },
                }));
              }catch(e) {
                console.log({message: "finishing: error", internalId, e});
                throw e;
              }
            }else {
              throw new Error("Path not exists");
            }
          };
      LoggingConfig:
        LogGroup: !Ref MonitoringLambdaLogGroup
        LogFormat: JSON
      Environment:
        Variables:
          RunIDTable: !GetAtt RunIDTable.Arn
          RunsTable: !GetAtt RunsTable.Arn
          LogsTable: !GetAtt LogsTable.Arn
          Monitors: !Ref Monitors
  MonitoringLambdaUrl:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !GetAtt MonitoringLambdaFunction.Arn
Outputs:
  CloudTrailSNSTopic:
    Value: !GetAtt CloudTrailSNSTopic.TopicArn
  AccessDeniedLogs:
    Value: !Sub
      - "https://${AWS::Region}.console.aws.amazon.com/cloudwatch/home#logsV2:log-groups/log-group/${CloudTrailLogsEscaped}/log-events"
      - CloudTrailLogsEscaped: !Join [ '$252F', !Split [ '/', !Ref SQSLogGroup ] ]
  MonitoringUrl:
    Value: !GetAtt MonitoringLambdaUrl.FunctionUrl
  MonitoringRegion:
    Value: !Ref AWS::Region
  Bucket:
    Value: !GetAtt Bucket.Arn
  BackupUser:
    Value: !Ref BackupUser
  MonitoringUser:
    Value: !Ref MonitoringUser
  ResticRepository:
    Value: !Sub "s3.dualstack.${AWS::Region}.amazonaws.com/${Bucket}"
